<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Android微信图片分享踩坑记录]]></title>
      <url>http://mayongnan.github.io/2017/05/23/wechat_share_defact/</url>
      <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近接手了一个“图片分享给微信好友清晰度优化”的任务，心想，这还不小菜一碟。首先看了下需求：公司app有个将界面生成一张长图片并支持微信分享的功能。正常来讲，分享的图片不清晰应该和图片压缩有关系，可是事实并非想象的那么简单，我们项目中的这个功能是先生成长图并保存到本地，之后直接调用微信分享API，通过传递本地路径的方式实现的。项目中图片生成相关代码本身并没有什么问题，保存到本地的图片是很清晰的，可是为什么分享出去的图片变模糊了？</p>
<h2 id="分析研究"><a href="#分析研究" class="headerlink" title="分析研究"></a>分析研究</h2><p>笔者对微信分享图片相关内容进行了一些研究。这里对测试过程中用到的手机和图片进行如下说明：</p>
<p>➣ 发送方手机均使用的Redmi Note4，5.5英寸分辨率为1920x1080</p>
<p>➣ 接收方（好友）手机均使用的三星GALAXY Note 3 Lite（N7508V/移动4G），5.5英寸分辨率为1280x720</p>
<p>➣ 截图规格：1080x1920px，263.32kb，png格式</p>
<p>➣ 生成图规格：1080x6596px，441.21kb，jpg格式（先根据Activity中显示的View，利用view.draw(canvas)绘制到使用Bitmap.Config.RGB_565色彩模式的Bitmap上，质量压缩30%，然后通过FileOutputStream输出保存图片）</p>
<h3 id="使用微信API进行分享"><a href="#使用微信API进行分享" class="headerlink" title="使用微信API进行分享"></a>使用微信API进行分享</h3><p>使用微信API进行分享，有两种方式，一种是发送图片的二进制数据，一种是发送图片的路径，具体可以参考<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419317340&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">微信开放平台</a>。或者直接下载<a href="https://res.wx.qq.com/open/zh_CN/htmledition/res/dev/download/sdk/WeChatSDK_sample_Android_5.0.2.rar" target="_blank" rel="noopener">范例代码</a>。</p>
<h4 id="1-发送图片的二进制数据"><a href="#1-发送图片的二进制数据" class="headerlink" title="1. 发送图片的二进制数据"></a>1. 发送图片的二进制数据</h4><p>使用图片的二进制数据进行分享，微信分享的SDK中默认会对Bitmap进行85%的质量压缩，而且微信的Demo中还对Bitmap进行了尺寸压缩（限制图片尺寸），最后是将图片转换成字节数组（byte[]）调用分享API进行的分享。</p>
<p>此种方式适合小图分享，发送出去的图片效果和我们最终处理之后的图片应该基本一致，笔者未做对比测试，其实无论使用那种方式进行微信图片分享，都会通过Intent启动微信的一个Activity（分享界面），对于这种方式，需要我们注意最终传递的字节数组的大小，不然很有可能发生<a href="https://developer.android.google.cn/reference/android/os/TransactionTooLargeException.html" target="_blank" rel="noopener">TransactionTooLargeException</a>。</p>
<h4 id="2-发送图片的本地路径"><a href="#2-发送图片的本地路径" class="headerlink" title="2. 发送图片的本地路径"></a>2. 发送图片的本地路径</h4><p>此种方式也是我们app中使用的图片分享方式，微信Demo中还传递了一个缩略图（thumbData字节数组长度限制在32k以内），主要用于微信好友选择界面，笔者发现如果不传缩略图，依然可以进行分享，比如我们直接分享一个长图，在微信好友选择界面看到的缩略图会以长图的中心为中心进行相应截取。</p>
<p><strong>发送1080x1920px，263.32kb截图</strong></p>
<p>发送到朋友圈：从发送方朋友圈看图片清晰度明显发生变化，从发送方微信朋友圈保存到本地，图片变为720x1280px，96.45k，从好友朋友圈保存到本地，图片变为720x1280px，92.27k，<strong>微信保存的图片均为jpg格式，以下不再做说明</strong>。</p>
<p>发送给好友：从发送方朋友圈看图片清晰度明显发生变化，从发送方微信朋友圈保存到本地，图片变为540x960px，244.38k，从好友朋友圈保存到本地，图片变为540x960px，238.65k。</p>
<p><strong>发送1080x6596px，441.21kb生成图</strong></p>
<p>发送到朋友圈：从发送方朋友圈看图片清晰度没有变化，从发送方微信朋友圈保存到本地，图片和原图一致，为1080x6596px，441.21k，从好友朋友圈保存到本地，图片变为1080x6596px，596.02k。</p>
<p>发送给好友：从发送方朋友圈看图片明显模糊了很多，但是从发送方微信朋友圈保存到本地，图片仍为1080x6596px，441.21k，在好友微信对话中查看也是非常模糊的，从好友朋友圈保存到本地，图片变为1080x6596px，430.87k。</p>
<p>由此可见，通过本地路径的分享方式，还是蛮坑的，对于普通图片进行分享，无论发送给好友还是分享到朋友圈，都会经过尺寸压缩，而且分享到朋友圈和分享给好友的压缩策略也不同。对于特殊图片（应该是图片尺寸比较大的，笔者试过1080x1920px，2.8M的图片进行测试，效果和“普通图片”结果类似，都会被按相同尺寸压缩），如笔者使用的生成图，在发送方，在发送成功之后，删除发送方本地的图片，再查看发送的记录，会出现“图片已过期或已被清理”，但朋友圈中的记录不受影响，而且保存到本地的文件和原图一模一样。对于我们的app来讲，因为发送的是长图，分享到朋友圈基本上没什么大问题，最大的坑就是分享给好友，好友在聊天记录中点开图片看到的是不清楚的，好在保存到本地之后是清晰的，可是谁会这样操作呢？所以微信的图片显示功能还是有待优化的。分析到这，笔者也已死心，笔者之前还好奇“大智慧”app中的图片分享为什么不模糊，反编译其代码才知道，“大智慧”app用的是“发送图片的二进制数据”的分享方式，真是心大。</p>
<h3 id="使用系统自带分享功能"><a href="#使用系统自带分享功能" class="headerlink" title="使用系统自带分享功能"></a>使用系统自带分享功能</h3><p>这里提一下系统分享，Android系统中一般都自带分享功能，使用系统自带的文件浏览工具，打开SD卡中的一张图片，或者直接使用“相册”选中一张图片，找到“发送”功能，并点击“发送”，系统便会将所有支持图片发送功能的app列出来供我们选择，这里选择微信或者朋友圈，就可以将图片发送给微信好友或者分享到朋友圈。</p>
<p>此种方式本质上和通过如下代码调起系统分享类似：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent shareIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">shareIntent.setAction(Intent.ACTION_SEND);</span><br><span class="line">shareIntent.putExtra(Intent.EXTRA_STREAM, imageUri);</span><br><span class="line">shareIntent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">startActivity(Intent.createChooser(shareIntent, <span class="string">"分享到"</span>));</span><br></pre></td></tr></table></figure></p>
<p>使用该方式分享到朋友圈的图片大小与原图相同，质量看不出差别；该方式分享给微信好友，发送的图片一般会被压缩，一些特殊的图片，像长图，在接收方可以选择“查看原图”，但是这里“查看原图”的大小与发送的原图所占磁盘空间是不同的。</p>
<p><strong>发送1080x1920px，263.32kb的截图</strong></p>
<p>发送到朋友圈：从发送方朋友圈看图片清晰度明显发生变化，从发送方微信朋友圈保存到本地，图片变为720x1280px，96.45k，从好友朋友圈保存到本地，图片变为720*1280px，92.27k。</p>
<p>发送给好友：从发送方朋友圈看图片清晰度明显发生变化，从发送方微信朋友圈保存到本地，图片变为720x1280px，107.57k，从好友朋友圈保存到本地，图片变为720*1280px，105.05k。</p>
<p><strong>发送1080x6596px，441.21kb的生成图</strong></p>
<p>发送到朋友圈：从发送方朋友圈看图片清晰度没有变化，从发送方微信朋友圈保存到本地，图片变为1080x6596px，441.21k，从好友朋友圈保存到本地，图片变为1080x6596px，596.02k。</p>
<p>发送给好友：从发送方朋友圈看图片清晰度没有变化，从发送方微信朋友圈保存到本地，图片变为1080x6596px，441.21k，好友微信对话中出现“查看原图（430K）”的选项，从好友朋友圈保存到本地，图片变为1080x6596px，430.87k。</p>
<p>根据测试结果，可以看出，至少对于长图来讲，分享出去的图片尺寸没有经过微信压缩，肉眼看都是和原图没什么差别。那能不能直接使用<code>Intent.ACTION_SEND</code>的方式直接调起微信分享的界面来达到我们app的分享需求呢？能是能，只要知道微信的包名和微信分享界面的Activity信息，进行定向分享即可，但这种方式貌似无法得知分享的结果（怎么告知微信分享的来源？），而且保不准分享界面的Activity信息哪天就变了，不太满足我们项目需求。</p>
<p>微信分享API中要调起的微信类信息如下（来自com.tencent.mm.opensdk.openapi.WXApiImplV10.class中sendReq(BaseReq var1)方法），微信可以根据appid进行回调，通知app分享结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">Args var6;</span><br><span class="line">(var6 = <span class="keyword">new</span> Args()).bundle = var2;</span><br><span class="line">var6.content = <span class="string">"weixin://sendreq?appid="</span> + <span class="keyword">this</span>.appId;</span><br><span class="line">var6.targetPkgName = <span class="string">"com.tencent.mm"</span>;</span><br><span class="line">var6.targetClassName = <span class="string">"com.tencent.mm.plugin.base.stub.WXEntryActivity"</span>;</span><br><span class="line"><span class="keyword">return</span> MMessageActV2.send(<span class="keyword">this</span>.context, var6);</span><br></pre></td></tr></table></figure></p>
<p>指定微信进行分享的代码如下(分享给微信好友)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();		</span><br><span class="line"><span class="comment">//朋友圈："com.tencent.mm.ui.tools.ShareToTimeLineUI"</span></span><br><span class="line"><span class="comment">//好友："com.tencent.mm.ui.tools.ShareImgUI"</span></span><br><span class="line">ComponentName comp = <span class="keyword">new</span> ComponentName(<span class="string">"com.tencent.mm"</span>,<span class="string">"com.tencent.mm.ui.tools.ShareImgUI"</span>);</span><br><span class="line">intent.setComponent(comp);</span><br><span class="line">intent.setAction(Intent.ACTION_SEND);</span><br><span class="line">intent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(file));<span class="comment">//uri为你要分享的图片的uri</span></span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<h2 id="附：图片生成"><a href="#附：图片生成" class="headerlink" title="附：图片生成"></a>附：图片生成</h2><p>View相关图片的生成方式，可以通过canvas绘制到指定大小的Bitmap上，类似代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">takeViewScreenShort</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        Bitmap result = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.RGB_565);</span><br><span class="line">        Canvas canvas = <span class="keyword">new</span> Canvas(result);</span><br><span class="line">        view.draw(canvas);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里还是要啰嗦下：Bitmap质量压缩不会影响Bitmap所占用的内存空间，Bitmap占用内存空间的计算方式始终是：占用内存 = 图片长度 <em> 图片宽度 </em> 单位像素占用的字节数。微信缩略图的处理一般既要使用尺寸压缩，又要使用质量压缩，以此限制thumbData长度。质量压缩会影响到该Bitmap保存到本地的文件大小。</p>
]]></content>
      
        <categories>
            
            <category> 开发随记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微信分享 </tag>
            
            <tag> 长图分享 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android中的MVC/MVP/MVVM框架模式]]></title>
      <url>http://mayongnan.github.io/2017/03/16/mvc_mvp_mvvm/</url>
      <content type="html"><![CDATA[<h2 id="架构、框架及设计模式"><a href="#架构、框架及设计模式" class="headerlink" title="架构、框架及设计模式"></a>架构、框架及设计模式</h2><p>关于架构、框架与设计模式之间的联系及区别，网上的答案五花八门，就连百度百科里的解释都很让人费解，百度百科里对“架构模式”的解释里提到MVC是一种架构模式，但在MVC的介绍里，是把MVC当成一种框架模式进行解释的，MVC是一种框架模式，但显然“框架”和“架构”不应该混为一谈。虽然百度百科本身就不具有专业性和权威性，但也从侧面反映出大家对于架构、框架以及设计模式之间的模糊认知，知乎上也有人发起提问：<a href="https://www.zhihu.com/question/31079945" target="_blank" rel="noopener">MVC到底是设计模式还是一种框架？</a>及<a href="https://www.zhihu.com/question/32105413" target="_blank" rel="noopener">架构、构架、结构、框架之间有什么区别？</a>。</p>
<p>本人认为《<a href="http://blog.csdn.net/lfsf802/article/details/8487990" target="_blank" rel="noopener">架构、框架和设计模式关系</a>》及《<a href="http://blog.csdn.net/liuguobo/article/details/43451129" target="_blank" rel="noopener">架构和框架的区别</a>》两篇文章中论述的较有说服力。当然，相比于概念而言，我们更应该关注和学习的是这些概念背后处理问题的思想。</p>
<blockquote>
<p>架构应该是一个范畴最大的概念，是最高层次的设计。一个架构设计中可能会用到多个框架和多个设计模式；而框架是针对共性抽象出来的半成品，这里面可能包含着多个设计模式；而设计模式就是解决一类问题的设计思路和解决方法。——《<a href="http://blog.csdn.net/lfsf802/article/details/8487990" target="_blank" rel="noopener">架构、框架和设计模式关系</a>》</p>
</blockquote>
<blockquote>
<p>框架和架构的关系可以总结为两句话：（1）为了尽早验证架构设计，或者处于支持产品线开发的目的，可以将关键的通用机制甚至整个架构以框架的方式进行实现；（2）业界（及公司内部）可能存在大量可供重用的框架，这些框架或者已经实现了软件架构所需的重要架构机制，或者为未来系统的某个子系统提供了可扩展的半成品，所以最终的软件架构可以借助这些框架构造。——《<a href="http://blog.csdn.net/liuguobo/article/details/43451129" target="_blank" rel="noopener">架构和框架的区别</a>》</p>
</blockquote>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC全称是Model-View-Controller即模型-视图-控制器，在1979年的时候由<a href="https://en.wikipedia.org/wiki/Trygve_Reenskaug" target="_blank" rel="noopener">TrygveReenskaug</a>提出，最早用于GUI开发。MVC是一个框架模式，它强制性的使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务,最典型的MVC就是JSP + servlet + javabean的模式。MVC分层有助于管理复杂的应用程序，因为我们可以在一个时间内专门关注一个方面。例如，我们可以在不依赖业务逻辑的情况下专注于视图设计。同时也让应用程序的测试更加容易。</p>
<p>Java Web中MVC（<a href="http://www.cnblogs.com/end/archive/2011/06/02/2068512.html" target="_blank" rel="noopener">主动型MVC</a>）的图示如下：<br><img src="https://mayongnan.github.io/blogfiles/20170315_MVC%20.png" alt="MVC"><br><code>Model</code>：在MVC的三个部件中，模型拥有最多的处理任务，也是MVC的核心。模型持有所有的数据、状态和程序逻辑。模型独立于视图和控制器。</p>
<p><code>View</code>：视图是用户看到并与之交互的界面，如就是html页面。</p>
<p><code>Controller</code>：定义用户界面对用户输入的响应方式，负责把用户的请求转化为对 模型的操作。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。</p>
<p>对于MVC似乎也没有明确的定义，前端、后端等不同平台的框架对于MVC的定义也不尽相同，要完全理解MVC并不是很容易。在MVC里，View是可以直接访问Model的，例如在jsp页面上，可以嵌套Java代码，这样在View上就可以越过Controller访问Model了，从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。在MVC模型里，Model不依赖于View，但是View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的，因为这部分不是公用的Model了，其他View不能使用这个View里面的代码。而在MVC中View会从直接Model中读取数据而不是通过<br>Controller。所以MVC中模型与视图并没有完全分离。而且控制层和表现层有时会过于紧密，导致没有真正分离和重用。</p>
<p>Android中的“MVC”结构由framework给我们搭建好并提供给我们的，View层采用XML文件进行界面描述，Model大多对应于本地的数据文件或网络获取的数据体及这些数据的处理，Controller由Activity承担，控制器Activity将视图View和模型Model进行分离，并让二者在Activity中进行绑定或完成其他逻辑。但是在这套“MVC”体系中，View的功能太弱，导致我们要把处理View的逻辑写到Activity中，如Dialog的显示，导致Activity即充当了Cotroller又充当了View的部分角色，不利于测试及代码复用，所以有些人认为这套“MVC”是一个Model-View的结构。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>分层，结构清晰，耦合性低，大型项目代码的复用性得到极大的提高，开发人员分工明确，提高了开发的效率，维护方便，降低了维护成本。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>简单的小型项目，使用MVC设计反而会降低开发效率，层和层虽然相互分离，但是之间关联性太强，没有做到独立的重用。</p>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP是从MVC模式演变而来，MVP的全称为Model-View-Presenter，Model提供数据，View负责显示，Controller/Presenter负责逻辑的处理。MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller。</p>
<p>MVP模式的图示如下：<br><img src="https://mayongnan.github.io/blogfiles/20170315_MVP.png" alt="MVP"><br><code>Model</code>：负责存储、检索、操纵数据。</p>
<p><code>View</code>：负责绘制UI元素、与用户进行交互。</p>
<p><code>Presenter</code>：作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。</p>
<p>MVP模式可以让UI界面和数据分离，我们的应用至少可以分为3层，这样使得我们也可以对这三层进行独立的单元测试。MVP并不是一个标准化的模式，它有很多种实现方式。</p>
<p>在Android开发中，主流的思想是把Activity、Fragment作为View角色看待，如<a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">谷歌sample</a>、<a href="http://hannesdorfmann.com/mosby/mvp/" target="_blank" rel="noopener">Mosby</a>、<a href="https://github.com/antoniolg/androidmvp" target="_blank" rel="noopener">AndroidMVP</a>等，因为Activity、Fragment更像是一个<code>ViewController</code>，View相关的逻辑都应该放到View层而不是Presenter层，这显然是比较合理的。</p>
<p>但也有一部分人将Activity、Fragment当成Presenter来处理，如<a href="https://github.com/qibin0506/MVPro" target="_blank" rel="noopener">MVPro</a>、<a href="https://github.com/kymjs/TheMVP" target="_blank" rel="noopener">TheMVP</a>等。因为activity 有一个很复杂的生命周期（fragment生命周期更为复杂）, 而这些生命周期很有可能对你项目的业务逻辑有非常重大的影响。 Activity可以获取上下文环境和多种android系统服务， Activity之间进行数据的传递、启动Service和执行FragmentTransaction等不应该是视图层应该涉及的领域。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>易于维护、易于测试、松耦合、复用性高、健壮稳定易于拓展</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>➣ Presenter层与View层通过接口进行交互，接口粒度不好控制。粒度太小，就会存在大量接口的情况，使代码太过碎版化；粒度太大，解耦效果不好。同时对于UI的输入和数据的变化，需要手动调用V层或者P层相关的接口，相对来说缺乏自动性、监听性。</p>
<p>➣ 主流的MVP是以UI为驱动的模型，更新UI都需要保证能获取到控件的引用，更新UI的时候要考虑当前是否在UI线程以及Activity的生命周期。数据是被动的通过UI控件做展示，如果数据的变化能够自动响应到UI将让我们的开发更高效。</p>
<p>➣ V层与P层有一定的耦合度，一旦V层某个UI元素更改，那么对应的接口可能就必须得改，数据如何映射到UI上、事件监听接口这些可能都需要转变，牵一发而动全身。</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM最早于 2005 年被微软的 WPF 和 Silverlight 的架构师 John Gossman 提出，并且应用在微软的软件开发中。MVVM 在使用当中，通常会利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。所以，MVVM 模式有些时候又被称作：model-view-binder 模式。MVVM与MVP很相似，都将Model和View层进行了分离，只是Presenter变成了ViewModel，同时它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。</p>
<p>MVVM模式的图示如下：<br><img src="https://mayongnan.github.io/blogfiles/20170315_MVVM.png" alt="MVVM"></p>
<p>2015年Google IO 大会上，Android 团队发布了数据绑定框架（Data Binding Library），从而提供了对MVVM模式的支持。ViewModel在改变内容之后通知binding framework内容发生了改变，然后framework自动更新和那些内容绑定的view。因为数据和业务逻辑处于一个独立的ViewModel中，ViewModel只需要关注数据和业务逻辑，不需要和UI或者控件打交道。UI想怎么处理数据都由UI自己决定，ViewModel不涉及任何和UI相关的事，也不持有UI控件的引用。Data Binding帮助我们一定程度上提升了开发效率，性能更高（甚至超越手写代码）并且具有强大的表达式支持。</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>➣ 数据驱动：在常规的开发模式中，数据变化需要更新UI的时候，需要先获取UI控件的引用，然后再更新UI。获取用户的输入和操作也需要通过UI控件的引用。在MVVM中，这些都是通过数据驱动来自动完成的，数据变化后会自动更新UI，UI的改变也能自动反馈到数据层，数据成为主导因素。这样MVVM层在业务逻辑处理中只要关心数据，不需要直接和UI打交道，在业务处理过程中简单方便很多。</p>
<p>➣ 低耦合：数据和业务逻辑处于一个独立的ViewModel中，ViewModel只需要关注数据和业务逻辑，不需要和UI或者控件打交道。UI想怎么处理数据都由UI自己决定，ViewModel不涉及任何和UI相关的事，也不持有UI控件的引用。即便是控件改变了（比如：TextView换成EditText），ViewModel也几乎不需要更改任何代码。它非常完美的解耦了View层和ViewModel，解决了上面我们所说的MVP的痛点。</p>
<p>➣ UI更新：在MVVM中，数据发生变化后，我们在工作线程直接修改（在数据是线程安全的情况下）ViewModel的数据即可，不用再考虑要切到主线程更新UI了，这些事情相关框架都帮我们做了。</p>
<p>➣ 团队协作：MVVM的分工是非常明显的，由于View和ViewModel之间是松散耦合的：一个是处理业务和数据、一个是专门的UI处理。所以，完全由两个人分工来做，一个做UI（XML和Activity）一个写ViewModel，效率更高。</p>
<p>➣ 可复用：一个ViewModel可以复用到多个View中。同样的一份数据，可以提供给不同的UI去做展示。对于版本迭代中频繁的UI改动，更新或新增一套View即可。如果想在UI上做A/B Testing，那MVVM是你不二选择。</p>
<p>➣ 单元测试：前面说过，ViewModel层做的事是数据处理和业务逻辑，View层中关注的是UI，两者完全没有依赖。不管是UI的单元测试还是业务逻辑的单元测试，都是低耦合的。在MVVM中数据是直接绑定到UI控件上的（部分数据是可以直接反映出UI上的内容），那么我们就可以直接通过修改绑定的数据源来间接做一些Android UI上的测试。</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>➣ 对于过大的项目，数据绑定需要花费更多的内存。</p>
<p>➣ 使用apt等技术动态生成代码，对于自定View需要借助注解写一些辅助代码才能实现绑定，View中使用的变量和具体类没有直接关联，可能要在编译的时候才能发现View中使用变量的属性名称有误。</p>
<p>➣ xml与ViewModel绑定，可能会影响xml布局复用性。</p>
<hr>
<p>&emsp;&emsp;讨论框架模式的目的是让我们能够从中获得启发，写出易于测试、复用率高、耦合度低、拓展性强且易于阅读的健壮型代码结构。对于设计模式我们应该理性对待，举个例子：谷歌的<a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="noopener">todo-mvp sample</a> 中有个打开任务详情界面的实现，首先在Fragment的onTaskClick方法中调用Presenter的openTaskDetails方法，然后在Presenter的openTaskDetails方法中调用Fragment中的showTaskDetailsUi方法，从MVP的分工来讲确实合情合理，但一个简单的打开Activity界面的操作要写这么多代码可能就显得有些繁琐了。其实MV*的思想都是进行解耦隔离视图（View）和模型（Model），在实际的应用中不需要给MVC、MVP和MVVM一个明确的界限,甚至可以把几者融合在一起，无形胜有形。</p>
<hr>
<p><strong>参考</strong><br><em>【1】<a href="http://www.cnblogs.com/greatfish/p/6024946.html" target="_blank" rel="noopener">Java中MVC详解以及优缺点总结</a><br>【2】《Android源码设计模式解析与实战》<br>【3】<a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">MVC，MVP 和 MVVM 的图示</a><br>【4】<a href="http://www.infoq.com/cn/articles/rethinking-mvc-mvvm/" target="_blank" rel="noopener">被误解的MVC和被神化的MVVM</a><br>【5】<a href="http://www.androidchina.net/6329.html" target="_blank" rel="noopener">如何构建Android MVVM 应用框架</a></em></p>
]]></content>
      
        <categories>
            
            <category> 技术随记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MVC </tag>
            
            <tag> MVP </tag>
            
            <tag> MVVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Annotation系列之编译时注解使用]]></title>
      <url>http://mayongnan.github.io/2017/01/26/annotation_class/</url>
      <content type="html"><![CDATA[<p>上一篇文章《<a href="http://mayongnan.github.io/2017/01/25/annotation_runtime/">Annotation系列之运行时注解使用</a>》中讲述了如何在程序运行时获取并处理运行时注解，但很多时候在运行时处理注解并不是很好的选择，尤其当程序中需要使用大量反射才能达到我们的目的时，这时编译时注解也许是非常好的选择。编译时注解（<code>RetentionPolicy.CLASS</code>）会被编译器保留，也就是说在编译时我们就可以处理注解，那么编译时怎么能够处理注解呢？答案就是注解处理器（<code>Annotation Processor</code>）。</p>
<p>我们可以参照《<a href="http://www.jianshu.com/p/d294bf008bec" target="_blank" rel="noopener">使用注解处理器生成代码</a>》中对注解处理器的介绍：</p>
<blockquote>
<p>注解处理器在 Java 5 引入, 但那时并没有标准化的 API 可用, 需通过 apt（Annotation Processing<br>Tool）结合 Mirror API（com.sun.mirror）来实现. Java 6 开始, 注解处理器被标准化, 定义在 JSR<br>269 标准中, 在标准库中提供了 API, apt 也被集成到 javac 工具中。</p>
</blockquote>
<p>以及《<a href="http://www.race604.com/annotation-processing/" target="_blank" rel="noopener">Java注解处理器</a>》中对注解处理器的功能描述：</p>
<blockquote>
<p>一个注解的注解处理器，以Java代码（或者编译过的字节码）作为输入，生成文件（通常是.java文件）作为输出。这具体的含义什么呢？你可以生成Java代码！这些生成的Java代码是在生成的.java文件中，所以你不能修改已经存在的Java类，例如向已有的类中添加方法。这些生成的Java文件，会同其他普通的手动编写的Java源代码一样被javac编译。</p>
</blockquote>
<p>注解处理器的强大功能造福了Java开发者，像<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">butterknife</a>、<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus3</a>等Android界比较有名的开源项目都有用到编译时注解，并为我们提供了非常方便实用的功能。</p>
<p>接下来我们同样仿照<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">butterknife</a>，新建一个项目，介绍使用编译时注解实现View注入及click事件设置的大致流程。</p>
<h2 id="1-创建项目结构"><a href="#1-创建项目结构" class="headerlink" title="1. 创建项目结构"></a>1. 创建项目结构</h2><p>&emsp;&emsp;一般编译时注解库会有多个<code>module</code>，为了简单起见，我们的示例中只以Activity为处理目标，这里先对示例项目结构做个简要说明，主要有以下模块：<br>➣ <code>annotation模块</code>：类型为Java Library，存放定义的编译时注解<br>➣ <code>processor模块</code>：类型为Java Library，存放注解处理器相关类，依赖annotation模块<br>➣ <code>api 模块</code>：类型为Android Library，依赖annotation模块，存放将Activity与注解处理器生成的注入处理类关联的api类<br>➣ <code>app模块</code>：依赖processor模块和api 模块，作为示例程序入口及演示</p>
<h2 id="2-定义注解"><a href="#2-定义注解" class="headerlink" title="2. 定义注解"></a>2. 定义注解</h2><p>&emsp;&emsp;在<code>annotation模块</code>中需要创建如下两个注解：</p>
<p>➣ <strong>定义绑定View的注解，有个int型值对应View的id</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➣ <strong>定义绑定View的Click方法的注解，同样有个int型值对应View的id</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindClick &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-定义注解处理器"><a href="#3-定义注解处理器" class="headerlink" title="3. 定义注解处理器"></a>3. 定义注解处理器</h2><p>&emsp;&emsp;在<code>processor模块</code>我们需要对上面定义的注解进行信息收集及java文件生成工作，我们的目标是能够根据一个<code>Activity</code>中的<code>@BindView</code>和<code>@BindClick</code>注解，生成对应的一个工具类，以<code>ReceiverActivity</code>（简单的显示登录信息）为例，我们的目标是利用注解处理器自动生成<code>ReceiverActivity_InjectUtil.java</code>文件，这样后面我们只需要在ReceiverActivity中想办法调用到<code>ReceiverActivity_InjectUtil .inject(...)</code>方法即可进行View绑定及Click事件设置，我们为每个使用注解的类生成的目标代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverActivity_InjectUtil</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(<span class="keyword">final</span> ReceiverActivity activity)</span> </span>&#123;</span><br><span class="line">    activity.mUserNameTextView = (android.widget.TextView)activity.findViewById(<span class="number">2131427417</span>);</span><br><span class="line">    activity.mPasswordTextView = (android.widget.TextView)activity.findViewById(<span class="number">2131427418</span>);</span><br><span class="line">    activity.findViewById(<span class="number">2131427419</span>).setOnClickListener(<span class="keyword">new</span> android.view.View.OnClickListener()&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(android.view.View view)</span> </span>&#123;</span><br><span class="line">               activity.onFinishClicked();</span><br><span class="line">           &#125;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-定义注解信息类ActivityAnnotatedInfo-java"><a href="#1-定义注解信息类ActivityAnnotatedInfo-java" class="headerlink" title="1. 定义注解信息类ActivityAnnotatedInfo.java"></a>1. 定义注解信息类<code>ActivityAnnotatedInfo.java</code></h3><p>&emsp;&emsp;一个<code>ActivityAnnotatedInfo</code>类对应一个<code>Activity</code>类文件，用于记录<code>Activity</code>中的注解信息并提供生成对应Java文件对象的模板，<code>ActivityAnnotatedInfo</code>类示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityAnnotatedInfo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成的java文件后缀名，如ReceiverActivity生成的对应java文件为ReceiverActivity_InjectUtil.java</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUFFIX = <span class="string">"_InjectUtil"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放Activity中一个id对应的注解信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, ActivityAnnotatedInfo.IdAnnotatedInfo&gt; viewIdMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String classPackage;<span class="comment">//Activity类所在包的包名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String className;<span class="comment">//Activity类的名称</span></span><br><span class="line"></span><br><span class="line">    ActivityAnnotatedInfo(String classPackage, String className) &#123;</span><br><span class="line">        <span class="keyword">this</span>.classPackage = classPackage;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBindField</span><span class="params">(<span class="keyword">int</span> id, String name, String type)</span> </span>&#123;</span><br><span class="line">        getTargetIdAnnotatedInfo(id).field = <span class="keyword">new</span> ActivityAnnotatedInfo.AnnotatedField(name, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBindMethod</span><span class="params">(<span class="keyword">int</span> id, String name, String parameterType)</span> </span>&#123;</span><br><span class="line">        getTargetIdAnnotatedInfo(id).method = <span class="keyword">new</span> ActivityAnnotatedInfo.AnnotatedMethod(name, parameterType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ActivityAnnotatedInfo.<span class="function">IdAnnotatedInfo <span class="title">getTargetIdAnnotatedInfo</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        ActivityAnnotatedInfo.IdAnnotatedInfo info = viewIdMap.get(id);</span><br><span class="line">        <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">            info = <span class="keyword">new</span> ActivityAnnotatedInfo.IdAnnotatedInfo(id);</span><br><span class="line">            viewIdMap.put(id, info);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getActivityName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classPackage + <span class="string">"."</span> + className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用JavaPoet创建Java文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">JavaFile <span class="title">createBinderClassFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String acName = getActivityName();</span><br><span class="line">        ClassName targetActivityName = ClassName.get(classPackage, className);</span><br><span class="line">        <span class="comment">//方法名（inject()）</span></span><br><span class="line">        MethodSpec.Builder injectMethodBuilder = MethodSpec.methodBuilder(<span class="string">"inject"</span>)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                .returns(<span class="keyword">void</span>.class)</span><br><span class="line">                .addParameter(targetActivityName, <span class="string">"activity"</span>,Modifier.FINAL);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, ActivityAnnotatedInfo.IdAnnotatedInfo&gt; entry : viewIdMap.entrySet()) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//遍历处理每个View，生成处理代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        MethodSpec injectMethod = injectMethodBuilder.build();</span><br><span class="line">        <span class="comment">//类名为：Activity名+$$InjectUtil.java</span></span><br><span class="line">        TypeSpec binderClass = TypeSpec.classBuilder(className + SUFFIX)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(injectMethod)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//构建java文件</span></span><br><span class="line">        <span class="keyword">return</span> JavaFile.builder(classPackage, binderClass)</span><br><span class="line">                .addFileComment(<span class="string">"auto generate InjectUtil class response to : $S "</span>, acName)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个R.id.xxx（View）相关的注解信息,一个id只能被注解到一个变量和一个方法中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IdAnnotatedInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">        ActivityAnnotatedInfo.AnnotatedField field;</span><br><span class="line">        ActivityAnnotatedInfo.AnnotatedMethod method;</span><br><span class="line"></span><br><span class="line">        IdAnnotatedInfo(<span class="keyword">int</span> id) &#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被注解的View成员变量信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedField</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 变量名称，如 mPasswordTextView</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * View类型，如 TextView</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> String type;<span class="comment">//变量</span></span><br><span class="line"></span><br><span class="line">        AnnotatedField(String name, String type) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.type = type;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被注解的Click方法信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedMethod</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 方法名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数类型，必须为View</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> String parameterType;</span><br><span class="line"></span><br><span class="line">        AnnotatedMethod(String name, String parameterType)&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.parameterType = parameterType;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;代码中使用到了<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a>用来构建java文件，当然我们也可以采用完全拼接的方式实现，这里不做过多介绍。下面我们还会用到<a href="https://github.com/google/auto/tree/master/service" target="_blank" rel="noopener">AutoService</a>，AutoService注解处理器是Google提供的，用于自动生成<a href="http://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html" target="_blank" rel="noopener">SPI</a>（Service Provider Interface）标准中约定的文件结构：<code>META-INF/services/配置文件</code>，这里的配置文件是指以服务接口命名的配置文件，文件中记录了服务接口具体的实现类；这里要自动生成的文件名为<code>javax.annotation.processing.Processor</code>，表明提供的是一个注解处理器服务，文件中只有一行代码：<code>com.example.runtime_processor.BindAnnotationProcessor</code>，记录了<code>Processor</code>服务的一个具体实现类是<code>BindAnnotationProcessor</code>，这样才能被注解处理工具（<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/apt/index.html" target="_blank" rel="noopener">Annotation Processing Tool</a> ）使用。使用AutoService省去了我们手动去创建SPI所约定的文件。<code>processor模块</code>中build.gradle文件如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'java'</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">compile <span class="title">fileTree</span><span class="params">(include: [<span class="string">'*.jar'</span>], dir: <span class="string">'libs'</span>)</span></span></span><br><span class="line"><span class="function">    compile <span class="title">project</span><span class="params">(<span class="string">':clazz_annotation'</span>)</span></span></span><br><span class="line"><span class="function">    compile 'com.google.auto.service:auto-service:1.0-rc2'</span></span><br><span class="line"><span class="function">    compile 'com.squareup:javapoet:1.8.0'</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">sourceCompatibility </span>= <span class="string">"1.7"</span></span><br><span class="line">targetCompatibility = <span class="string">"1.7"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-创建注解处理器BindAnnotationProcessor-java类"><a href="#2-创建注解处理器BindAnnotationProcessor-java类" class="headerlink" title="2. 创建注解处理器BindAnnotationProcessor.java类"></a>2. 创建注解处理器<code>BindAnnotationProcessor.java</code>类</h3><p>&emsp;&emsp;所有的注解处理器都要继承<code>AbstractProcessor</code>类，并复写 <code>process(...)</code> 方法，通常我们会复写4个方法来实现一个完整的注解处理器功能，<code>BindAnnotationProcessor.java</code>示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来处理Element（表示程序元素（如包、类或方法）,每个元素代表静态的、语言级别的结构（而不是虚拟机的运行时结构））的工具类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Elements elementUtils;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来处理TypeMirror（Java编程语言中的类）的工具类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Types typeUtils;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Filer filer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一个注解处理器类都必须有一个空的构造函数。</span></span><br><span class="line"><span class="comment">     * 然而，这里有一个特殊的init()方法，它会被注解处理工具调用，并输入ProcessingEnviroment参数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> processingEnvironment ProcessingEnvironment提供很多有用的工具类,如Elements, Types和Filer。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnvironment);</span><br><span class="line">        <span class="comment">//在这里进行工具的初始化</span></span><br><span class="line">        elementUtils = processingEnvironment.getElementUtils();</span><br><span class="line">        typeUtils = processingEnvironment.getTypeUtils();</span><br><span class="line">        filer = processingEnvironment.getFiler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这相当于每个处理器的主函数main()。</span></span><br><span class="line"><span class="comment">     * 在这里进行注解的收集，以及Java文件的创建工作。</span></span><br><span class="line"><span class="comment">     * 通过输入参数RoundEnvironment可以查询出包含特定注解的被注解元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> set 请求被处理的注解类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> roundEnvironment  当前和前一轮的信息环境</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 请求被处理的注解类型是否已被当前处理器声明并不需要后续Processor处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//收集所有Activity类文件中的注解信息</span></span><br><span class="line">        Map&lt;TypeElement, ActivityAnnotatedInfo&gt; targetClassMap = findAndParseTargets(roundEnvironment);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;TypeElement, ActivityAnnotatedInfo&gt; entry : targetClassMap.entrySet()) &#123;</span><br><span class="line">            TypeElement typeElement = entry.getKey();</span><br><span class="line">            ActivityAnnotatedInfo classBindInfo = entry.getValue();</span><br><span class="line">            <span class="comment">// 为每个注解的Activity生成java文件</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                JavaFile jfo = classBindInfo.createBinderClassFile();</span><br><span class="line">                jfo.writeTo(filer);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                error(typeElement, <span class="string">"Unable to generate InjectUtil for type %s: %s"</span>, typeElement, e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里你必须指定，这个注解处理器是注册给哪个注解的。</span></span><br><span class="line"><span class="comment">     * 注意，它的返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称。</span></span><br><span class="line"><span class="comment">     * 换句话说，你在这里定义你的注解处理器注册到哪些注解上。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//表明该注解处理器只处理@BindView和@BindClick两个注解</span></span><br><span class="line">        Set&lt;String&gt; annotations = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        annotations.add(BindView.class.getCanonicalName());</span><br><span class="line">        annotations.add(BindClick.class.getCanonicalName());</span><br><span class="line">        <span class="keyword">return</span> annotations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来指定你使用的Java版本。通常这里返回SourceVersion.latestSupported()。</span></span><br><span class="line"><span class="comment">     * 在Java 7中，你也可以使用下面两个注解来代替getSupportedAnnotationTypes()和getSupportedSourceVersion()</span></span><br><span class="line"><span class="comment">     * 1、<span class="doctag">@SupportedSourceVersion</span>(SourceVersion.latestSupported())</span></span><br><span class="line"><span class="comment">     * 2、<span class="doctag">@SupportedAnnotationTypes</span>(&#123; //合法注解全名的集合 &#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedSourceVersion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-提供api"><a href="#4-提供api" class="headerlink" title="4. 提供api"></a>4. 提供api</h2><p>&emsp;&emsp;前面已经定义了注解、并定义了能够生成注解对应工具类的注解处理器，我们还需要提供一个工具类来将使用注解的类与注解处理器生成的类进行关联，在<code>api 模块</code>创建<code>BindInjector.java</code>类，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BindInjector</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BindAnnotationProcessor生成的java文件后缀名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUFFIX = <span class="string">"_InjectUtil"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BindInjector"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Method&gt; INJECT_UTILS = <span class="keyword">new</span> LinkedHashMap&lt;Class&lt;?&gt;, Method&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method NO_OP = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为xxActivity找到并调用xxActivity_InjectUtil工具类的inject方法进行注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = activity.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"Looking up view injector for "</span> + targetClass.getName());</span><br><span class="line">            Method inject = findInjectUtilMethodForClass(targetClass);</span><br><span class="line">            <span class="keyword">if</span> (inject != NO_OP) &#123;</span><br><span class="line">                inject.invoke(<span class="keyword">null</span>, activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnableToInjectException(<span class="string">"Unable to inject views for "</span> + activity, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找cls对应的工具类方法并进行缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Method <span class="title">findInjectUtilMethodForClass</span><span class="params">(Class&lt;?&gt; cls)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        Method inject = INJECT_UTILS.get(cls);</span><br><span class="line">        <span class="keyword">if</span> (inject != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"HIT: Cached in injector map."</span>);</span><br><span class="line">            <span class="keyword">return</span> inject;</span><br><span class="line">        &#125;</span><br><span class="line">        String clsName = cls.getName();</span><br><span class="line">        <span class="keyword">if</span> (clsName.startsWith(<span class="string">"android."</span>) || clsName.startsWith(<span class="string">"java."</span>)) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"MISS: Reached framework class. Abandoning search."</span>);</span><br><span class="line">            <span class="keyword">return</span> NO_OP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; injector = Class.forName(clsName + SUFFIX);</span><br><span class="line">            inject = injector.getMethod(<span class="string">"inject"</span>, cls);</span><br><span class="line">            Log.d(TAG, <span class="string">"HIT: Class loaded injection class."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"Not found. Trying superclass "</span> + cls.getSuperclass().getName());</span><br><span class="line">            inject = findInjectUtilMethodForClass(cls.getSuperclass());</span><br><span class="line">        &#125;</span><br><span class="line">        INJECT_UTILS.put(cls, inject);</span><br><span class="line">        <span class="keyword">return</span> inject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnableToInjectException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">        UnableToInjectException(String message, Throwable cause) &#123;</span><br><span class="line">            <span class="keyword">super</span>(message, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-使用定义的注解、注解处理器及API"><a href="#5-使用定义的注解、注解处理器及API" class="headerlink" title="5. 使用定义的注解、注解处理器及API"></a>5. 使用定义的注解、注解处理器及API</h2><p>&emsp;&emsp;在<code>app模块</code>我们需要使用注解处理器以及api,因此需要添加<code>processor模块</code>、<code>api模块</code>的引用，但注解处理器只在编译处理期间需要用到，编译处理完后就没有实际作用了，在主项目直接引用<code>processor模块</code>的话就会产生冗余文件，为了处理这个问题我们需要引入<a href="https://bitbucket.org/hvisser/android-apt" target="_blank" rel="noopener">android-apt</a>插件，首先要在project目录的build.gradle中添加依赖，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()<span class="comment">// add</span></span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.2.3'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    The android-apt plugin assists in working with annotation processors in combination with Android Studio. It has two purposes:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    1、Allow to configure a compile time only annotation processor as a dependency, not including the artifact in the final APK or library</span></span><br><span class="line"><span class="comment">//    2、Set up the source paths so that code that is generated from the annotation processor is correctly picked up by Android Studio</span></span><br><span class="line">        classpath <span class="string">'com.neenbedankt.gradle.plugins:android-apt:1.8'</span><span class="comment">// add</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着我们需要在<code>app模块</code>的build.gradle中使用apt,代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line">apply plugin: <span class="string">'com.neenbedankt.android-apt'</span> <span class="comment">// add</span></span><br><span class="line">android &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">compile <span class="title">fileTree</span><span class="params">(include: [<span class="string">'*.jar'</span>], dir: <span class="string">'libs'</span>)</span></span></span><br><span class="line"><span class="function">    compile 'com.android.support:appcompat-v7:24.2.1'</span></span><br><span class="line"><span class="function">    <span class="comment">//引用api模块</span></span></span><br><span class="line"><span class="function">    compile <span class="title">project</span><span class="params">(<span class="string">':api'</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">//compile project(':runtime_processor')  替换为下面，不会将processor代码打包到apk中，只在编译时使用</span></span></span><br><span class="line"><span class="function">    apt <span class="title">project</span><span class="params">(<span class="string">':processor'</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>添加好依赖之后我们就可以使用了，<code>ReceiverActivity</code>的示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_NAME = <span class="string">"user_name"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">"password"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Context context, String userName, String password)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setClass(context, ReceiverActivity.class);</span><br><span class="line">        intent.putExtra(USER_NAME, userName);</span><br><span class="line">        intent.putExtra(PASSWORD, password);</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BindView</span>(R.id.tv_user_name)</span><br><span class="line">    TextView mUserNameTextView;</span><br><span class="line">    <span class="meta">@BindView</span>(R.id.tv_password)</span><br><span class="line">    TextView mPasswordTextView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_receiver);</span><br><span class="line">        <span class="comment">//使用自定义注入库</span></span><br><span class="line">        BindInjector.inject(<span class="keyword">this</span>);</span><br><span class="line">        Intent intent = getIntent();</span><br><span class="line">        <span class="keyword">if</span> (intent.getExtras() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mUserNameTextView.setText(getString(R.string.user_name_text, intent.getStringExtra(USER_NAME)));</span><br><span class="line">            mPasswordTextView.setText(getString(R.string.password_text, intent.getStringExtra(PASSWORD)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BindClick</span>(R.id.btn_finish)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFinishClicked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.finish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，我们已经介绍完了运行时注解的使用过程，因为涉及到的内容较多，这里只是尽可能简单的介绍了一个简化版butterknife的开发流程，细节性东西一带而过，Demo源码详见<a href="https://github.com/mayongnan/RetentionPolicy" target="_blank" rel="noopener">关于三种注解类型的示例Demo</a>。</p>
]]></content>
      
        <categories>
            
            <category> 技术随记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android Annotation </tag>
            
            <tag> RetentionPolicy.CLASS </tag>
            
            <tag> 编译时注解 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Annotation系列之运行时注解使用]]></title>
      <url>http://mayongnan.github.io/2017/01/25/annotation_runtime/</url>
      <content type="html"><![CDATA[<p>运行时注解（<code>RetentionPolicy.RUNTIME</code>）会被JVM保留，因此我们在代码运行过程中我们可以对类中使用的运行时注解信息进行获取和处理，运行时注解一般和动态代理配合使用，当然我们也可以利用反射根据注解信息对注解的对象进行相关使用。我们比较熟悉的网络库<a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a>就是通过定义了一系列运行时注解，在程序运行期间根据相应Service接口生成<code>动态代理类</code>，执行方法时会将Service接口方法中声明的注解信息转化成一个HTTP Call并进行相应的请求、数据解析及回调处理。</p>
<p>本篇将着重于描述如何获取动态注解信息，我们将定义一个运行时注解，类似<a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">Butter Knife</a>的功能（Butter Knife使用的是编译时注解，在下一篇文章中探讨），只要使用注解就可以省去<code>findViewById</code>相关重复性代码（注：代码仅用于示例，因为反射的性能问题等并不具有使用价值）。</p>
<h2 id="1-定义注解"><a href="#1-定义注解" class="headerlink" title="1. 定义注解"></a>1. 定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明注解范围为成员变量</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="comment">//声明注解为运行时注解</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FindViewById &#123;</span><br><span class="line">    <span class="comment">//定义一个int类型的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-编写注解处理工具类"><a href="#2-编写注解处理工具类" class="headerlink" title="2. 编写注解处理工具类"></a>2. 编写注解处理工具类</h2><p>在这里我们需要了解下<a href="http://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">AnnotatedElement</a>接口，其在<code>java.lang.reflect</code>包中，代表当前运行在VM中的程序的一个注解元素，<code>AnnotatedElement</code>接口允许注解信息被反射读取。该接口的方法中返回的注解信息都是不可变和可序列化的。该接口方法返回的数据可以被调用者修改而不影响返回给其他调用者的数组信息。我们在反射中用到的 <code>Class</code>, <code>Constructor</code>,  <code>Field</code>, <code>Method</code>, <code>Parameter</code>等都是实现了<code>AnnotatedElement</code>接口，因此都可以通过<code>AnnotatedElement</code>接口中定义的方法获取到这些元素上面的注解信息。这里列出常用几个常用方法：</p>
<p>➣ <code>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</code>: 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</p>
<p>➣ <code>Annotation[] getAnnotations()</code>:返回该程序元素上存在的所有注解。</p>
<p>➣ <code>Annotation[] getDeclaredAnnotations()</code>：返回直接存在于此元素上的所有注解。与接口中的其他方法不同，该方法将忽略继承的注解。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组）该方法的调用者可以随意修改返回的数组，不会对其他调用者返回的数组产生任何影响。</p>
<p>示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了简单演示，我们的工具类只针对Activity进行处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了简单演示，我们的工具类只针对Activity进行处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(<span class="keyword">final</span> Activity target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//收集当前Activity及父类Activity中Field信息（防止遗漏父类中使用的注解）</span></span><br><span class="line">        Class targetClass = target.getClass();</span><br><span class="line">        List&lt;Field&gt; fieldList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (targetClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Field[] fields = targetClass.getDeclaredFields();</span><br><span class="line">            Collections.addAll(fieldList, fields);</span><br><span class="line">            targetClass = targetClass.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Field field : fieldList) &#123;</span><br><span class="line">            <span class="comment">//获取@FindViewById注解的成员变量</span></span><br><span class="line">            FindViewById annotation = field.getAnnotation(FindViewById.class);</span><br><span class="line">            <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="comment">//通过findViewById找到对应View并为View变量反射赋值</span></span><br><span class="line">                    field.set(target, target.findViewById(annotation.value()));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"can't find view by id :"</span> + annotation.value());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-使用注解及工具类"><a href="#3-使用注解及工具类" class="headerlink" title="3. 使用注解及工具类"></a>3. 使用注解及工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FindViewById</span>(R.id.btn_sign_in)</span><br><span class="line">    <span class="keyword">private</span> Button mSubmitBtn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//使用工具类解析注解信息并赋值</span></span><br><span class="line">        ViewInjector.inject(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//mSubmitBtn将会指向@FindViewById中id对应的View</span></span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>,<span class="string">"mSubmitBtn:"</span>+mSubmitBtn,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似我们可以通过反射获取到方法中的注解信息，就像刚开始提到的，我们只需要学会注解信息的获取方式即可，Demo源码详见<a href="https://github.com/mayongnan/RetentionPolicy" target="_blank" rel="noopener">关于三种注解类型的示例Demo</a>。</p>
]]></content>
      
        <categories>
            
            <category> 技术随记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android Annotation </tag>
            
            <tag> RetentionPolicy.RUNTIME </tag>
            
            <tag> 运行时注解 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Annotation系列之源码级注解使用]]></title>
      <url>http://mayongnan.github.io/2017/01/24/annotation_source/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;在上一篇文章《<a href="http://mayongnan.github.io/2017/01/23/annotation_basic/">Annotation系列之基础篇</a>》中，我们知道源码级注解(<code>RetentionPolicy.SOURCE</code>)在编译时会被忽略，通常用来在编写代码时进行错误检查、抑制警告以及变量值限制等。当然我们也可以自定义注解处理器（<code>Annotation Processor</code>），通过运行注解处理器收集注解信息并进行相应处理，不过一般自定义注解处理器用于配合编译时注解（<code>RetentionPolicy.CLASS</code>）使用，我们将在后面的文章中进行介绍，在这篇文章中主要介绍上一篇文章中提到的利用注解代替枚举类型（<code>enum</code>）的使用。</p>
<p>&emsp;&emsp;在官网<a href="https://developer.android.google.cn/topic/performance/memory.html#Overhead" target="_blank" rel="noopener">Manage Your App’s Memory</a>文章中有提到 </p>
<blockquote>
<p>enums often require more than twice as much memory as static<br>constants. You should strictly avoid using enums on Android.</p>
</blockquote>
<p>&emsp;&emsp;网上也有不少关于Android开发中尽量避免使用枚举类型的讨论，比如<br>《<a href="http://blog.csdn.net/warden032/article/details/52452035" target="_blank" rel="noopener">android开发之避免使用枚举</a>》中提到的，枚举会增加dex文件大小，增加dex文件方法数量等一系列问题，因此如果能够通过使用注解来替代一般枚举类型的使用，我们又何乐而不为呢。</p>
<p>&emsp;&emsp;在一些开发过程中，我们可能需要根据用户操作及数据请求结果进行不同的视图展示。以登录为例，用户点击登录按钮后，我们一般会显示一个进度条，同时进行数据登录验证，验证成功的话进入相应界面，失败则提示用户登录失败信息。</p>
<h2 id="1-定义状态常量"><a href="#1-定义状态常量" class="headerlink" title="1. 定义状态常量"></a>1. 定义状态常量</h2><p>我们知道interface中的属性默认使用public final static修饰， 因此一般我们会将常量定义在interface中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SignInProgress</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录进行中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> START = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> SUCCESS = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> FAILURE = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-编写注解类型"><a href="#2-编写注解类型" class="headerlink" title="2. 编写注解类型"></a>2. 编写注解类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限定Annotation所饰的对象为方法参数</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</span><br><span class="line"><span class="comment">//限定注解的元素值</span></span><br><span class="line"><span class="meta">@IntDef</span>(&#123;SignInProgress.START, SignInProgress.SUCCESS, SignInProgress.FAILURE&#125;)</span><br><span class="line"><span class="comment">//定义该Annotation为Source级</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SignInState &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-使用注解"><a href="#3-使用注解" class="headerlink" title="3. 使用注解"></a>3. 使用注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateSignInState</span><span class="params">(@SignInState <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> SignInProgress.START:</span><br><span class="line">                <span class="comment">//显示进度条</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SignInProgress.SUCCESS:</span><br><span class="line">                <span class="comment">//隐藏进度条，finish界面并进行登录成功跳转</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SignInProgress.FAILURE:</span><br><span class="line">                <span class="comment">//隐藏进度条，并进行登录异常提示</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>switch-case中必须使用SignInProgress接口中定义的常量值，否则将会出现如下警告：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Don<span class="string">'t use a constant here; expected one of: SignInProgress.FAILURE, SignInProgress.START, SignInProgress.SUCCESS</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 技术随记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android Annotation </tag>
            
            <tag> RetentionPolicy.SOURCE </tag>
            
            <tag> 源码级注解 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Annotation系列之基础篇]]></title>
      <url>http://mayongnan.github.io/2017/01/23/annotation_basic/</url>
      <content type="html"><![CDATA[<h2 id="什么是Java-Annotation"><a href="#什么是Java-Annotation" class="headerlink" title="什么是Java Annotation"></a>什么是Java Annotation</h2><p>Java语言规范中对Annotation的说明如下：</p>
<blockquote>
<p>An annotation is a marker which associates information with a program construct, but has no effect at run time. An annotation denotes a specific invocation of an annotation type and usually provides values for the elements of that type. — <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.7" target="_blank" rel="noopener">Annotations</a></p>
</blockquote>
<p>在<a href="http://docs.oracle.com/javase/tutorial/java/annotations/index.html" target="_blank" rel="noopener">Java™ Tutorials</a>中也有较为详细的说明，内容如下<br>&emsp;&emsp;注解是元数据的一种形式，它提供了关于一个程序的数据但它并不是程序本身的组成部分。注解对被注解的代码执行没有任何直接影响。<br>注解通常有如下几个用途：<br>➣ 为编译器提供信息 — 注解可以被编译器用来检查错误或者禁止显示警告（suppress warnings）<br>➣ 编译时和部署时处理 — 软件工具可以通过处理注解信息来生成代码、XML文件等<br>➣ 运行时处理 — 一些注解可以在运行时被检查<br>使用注解以@开头来告诉编译器接下来是一个注解，注解中可以有命名或者未命名的元素信息，通常当注解只有一个元素的时候我们可以省略名称</p>
<h3 id="注解的格式"><a href="#注解的格式" class="headerlink" title="注解的格式"></a>注解的格式</h3><p>最简单的注解格式看起来像下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br></pre></td></tr></table></figure></p>
<p>@符号向编译器指明接来下是一个注解，下面的注解的大家应该都不陌生，注解名是Override：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySuperMethod</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>注解可以包含元素，可以是有名称的和没有名称的，并且这些元素都有值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Author</span>(</span><br><span class="line">    name = <span class="string">"Benjamin Franklin"</span>,</span><br><span class="line">    date = <span class="string">"3/27/2003"</span></span><br><span class="line">)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>() </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>或者像下面这个注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(value = <span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>当只有一个元素叫value的时候，name可以省略，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果注解没有元素的话，括号也可以被省略，就像上面的@Override<br>我们也可以在同一个声明中使用多注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Author</span>(name = <span class="string">"Jane Doe"</span>)</span><br><span class="line"><span class="meta">@EBook</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果注解具有相同的类型，我们叫“重复注解”，重复注解在Java SE 8中支持（<a href="http://docs.oracle.com/javase/tutorial/java/annotations/repeating.html" target="_blank" rel="noopener">Repeating Annotations</a>）。注解类型可以是java.lang 或 java.lang.annotation包中定义的，上面的例子中 Override 和 SuppressWarnings是预定义的注解，我们也可以自定义注解，上面例子中Author 和 Ebook 是自定注解。</p>
<h3 id="注解可以被用在什么地方"><a href="#注解可以被用在什么地方" class="headerlink" title="注解可以被用在什么地方"></a>注解可以被用在什么地方</h3><p>注解可以被用于声明：类、字段、方法和其它程序元素上。在Java SE 8 release中，注解也可以被用于类的使用上，如类的实例创建语句、类型转化、类继承以及抛出异常声明，这中形式的注解叫<a href="http://docs.oracle.com/javase/tutorial/java/annotations/type_annotations.html" target="_blank" rel="noopener">a type annotation</a>。</p>
<h2 id="预定义注解"><a href="#预定义注解" class="headerlink" title="预定义注解"></a>预定义注解</h2><p>在Java SE API中预定义了一些注解，其中一些注解在Java编译器中被使用，也有一些注解适用于其它注解。Android中也有很多预定义注解，如常用的android.support.annotation包中预定义的注解，通常用于辅助性的代码检查。</p>
<h3 id="Java语言中使用的注解类型"><a href="#Java语言中使用的注解类型" class="headerlink" title="Java语言中使用的注解类型"></a>Java语言中使用的注解类型</h3><p>这类预定义注解在java.lang包中，如下：<br>➣ <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html" target="_blank" rel="noopener">@Deprecated</a>表示被标记的元素过时并且不应该再被使用。当一个程序使用了 @Deprecated 标记的方法、类或者变量时,编译器会生成一个警告。当一个元素过时了，我们也应该在文档注释中使用Javadoc的@deprecated标签。文档注释中的@符号和注解中的@符号在概念上是相关的，并且一个以小写开头，一个以大写开头，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Javadoc comment follows</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span></span></span><br><span class="line"><span class="comment">     * explanation of why it was deprecated</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deprecatedMethod</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>➣ <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html" target="_blank" rel="noopener">@Override</a>告诉编译器该元素会覆盖父类中声明的对应元素，也就是方法的重写。当我们进行方法重写的时候，这个注解并不是必须的，但能帮助我们避免错误，当一个方法被@Override标记，但没有正确覆写，如方法名拼错的时候，编译器会报错，用法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mark method as a superclass method</span></span><br><span class="line">   <span class="comment">// that has been overridden</span></span><br><span class="line">   <span class="meta">@Override</span> </span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">overriddenMethod</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>➣ <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html" target="_blank" rel="noopener">@SuppressWarnings</a>告诉编译器去除将会生成的指定的警告。下面的例子中一个过时的方法被使用，通常编译器会生成一个警告，在这个例子中，@SuppressWarnings注解会抑制警告，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use a deprecated method and tell </span></span><br><span class="line">   <span class="comment">// compiler not to generate a warning</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">useDeprecatedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// deprecation warning</span></span><br><span class="line">        <span class="comment">// - suppressed</span></span><br><span class="line">        objectOne.deprecatedMethod();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;每个编译器警告都属于一个类别。Java语言规范中列出了两类：<code>deprecation</code>和<code>unchecked</code>。<code>unchecked</code>警告在我们使用泛型可能会遇到，要想抑制多个类别的警告，可以使用下面的语法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"deprecation"</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<p>➣ <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SafeVarargs.html" target="_blank" rel="noopener">@SafeVarargs</a>在Java SE 7中引入（以上三个在Java SE 5中也就是1.5中引入），当被用于一个方法或者构造方法时，断言了代码中的可变参数不会产生潜在的不安全操作。当这个注解被使用的时候，可变参数相关的<code>unchecked</code>警告会被抑制。<br>➣ <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html" target="_blank" rel="noopener">@FunctionalInterface</a>在Java SE 8中引入，表明类声明为一个函数式接口，该注解只能标记在有且仅有一个抽象方法的接口上（JDK8中interface中的<code>static</code>方法和<code>default</code>方法不算抽象方法）。该注解不是必须的，如果一个接口符合“函数式”接口定义，可以不加，加上后能够让编译器对函数式接口进行检查。我们常用的一些接口<code>Callable</code>、<code>Runnable</code>、<code>Comparator</code>等在JDK8中都添加了@FunctionalInterface注解。<a href="http://www.jianshu.com/p/0b4b59966276" target="_blank" rel="noopener">语言设计者投入了大量精力来思考如何使现有的函数友好地支持lambda，最终采取的方法是：增加函数式接口的概念。</a>。</p>
<h3 id="适用于其它注解上的注解"><a href="#适用于其它注解上的注解" class="headerlink" title="适用于其它注解上的注解"></a>适用于其它注解上的注解</h3><p>适用于其它注解上的注解，叫元注解 （meta-annotations），在<code>java.lang.annotation</code>包中定义了如下几个元注解：<br>➣ <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html" target="_blank" rel="noopener">@Retention</a>指明了标记注解保留的时间，如果在注解类声明中没有Retention注解，默认保留策略为RetentionPolicy.CLASS。<br>&emsp;&emsp;● <code>RetentionPolicy.SOURCE</code>：source级别注解，编译时将会被忽略<br>&emsp;&emsp;● <code>RetentionPolicy.CLASS</code>：编译时注解，会被编译器保留，但在JVM中会被忽略<br>&emsp;&emsp;● <code>RetentionPolicy.RUNTIME</code>：运行时注解，会被JVM保留<br>➣ <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Documented.html" target="_blank" rel="noopener">@Documented</a>表明无论什么时候使用被@Document注解声明的注解，被使用的元素都应该被Javadoc工具文档化（默认情况下注解不在Javadoc中），也就是说注解类型信息也会被包括在生成的<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/index.html" target="_blank" rel="noopener">Javadoc</a>文档中。通常我们使用@Document来替代代码中格式相同的注释。<br>➣ <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html" target="_blank" rel="noopener">@Target</a>表明被标记的注解被使用的限定范围，目标注解指定下列元素类型作为其值：<br>&emsp;&emsp;● <code>ElementType.ANNOTATION_TYPE</code>：可以被用于一个注解类上<br>&emsp;&emsp;● <code>ElementType.CONSTRUCTOR</code>：表明注解用于构造方法中<br>&emsp;&emsp;● <code>ElementType.FIELD</code>：表明注解用于成员变量或者属性中<br>&emsp;&emsp;● <code>ElementType.LOCAL_VARIABLE</code>：表明注解用于局部变量<br>&emsp;&emsp;● <code>ElementType.METHOD</code>：表明注解用于方法<br>&emsp;&emsp;● <code>ElementType.PACKAGE</code>：表明注解用于包名声明上<br>&emsp;&emsp;● <code>ElementType.PARAMETER</code>：表明注解用于方法的参数<br>&emsp;&emsp;● <code>ElementType.TYPE</code> 表明注解用于类元素上<br>➣ <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Inherited.html" target="_blank" rel="noopener">@Inherited</a>表明注解类可以从父类继承（默认不可以）。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类，也就是通过子类可以获取到父类的相应注解信息。<br>➣ <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Repeatable.html" target="_blank" rel="noopener">@Repeatable</a> Java SE 8中引入，表明标记的注解可以被同一个声明或者类使用多次，详细信息可以查看<a href="http://docs.oracle.com/javase/tutorial/java/annotations/repeating.html" target="_blank" rel="noopener">Repeating Annotations</a>。</p>
<h3 id="Android中预定义的注解"><a href="#Android中预定义的注解" class="headerlink" title="Android中预定义的注解"></a>Android中预定义的注解</h3><p>注解在android中是非常常见的，在官网搜索annotation会出现如下结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android.annotation</span><br><span class="line">android.support.annotation</span><br><span class="line">android.support.test.annotation</span><br><span class="line">android.test.suitebuilder.annotation</span><br><span class="line">android.text.Annotation</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>这里说下android.support.annotation包中提供的注解，该包中的注解类型可以分为<a href="https://asce1885.gitbooks.io/android-rd-senior-advanced/content/shen_ru_qian_chu_android_support_annotations.html" target="_blank" rel="noopener">三类</a>：<br>➣ <strong>Nullness注解</strong>：如使用<code>@NonNull</code>注解修饰的参数不能为null，使用<code>@Nullable</code>注解修饰的函数参数或者返回值可以为null<br>➣ <strong>资源类型注解</strong>：如可以使用<code>@StringRes</code>限定方法中int类型参数需要为String资源id<br>➣ <strong>Def类注解</strong>：基于Intellij的“魔术常量”检查机制，如：可以使用<code>@IntDef</code>限定方法中形式参数为指定的int常量值，以此代替枚举类型，同样可以使用<code>@StringDef</code>限定形式参数为指定的String常量值。</p>
]]></content>
      
        <categories>
            
            <category> 技术随记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Annotations </tag>
            
            <tag> Android Annotation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何复用FragmentActivity被系统杀掉之前所保存的Fragment]]></title>
      <url>http://mayongnan.github.io/2016/12/30/fragment_restore/</url>
      <content type="html"><![CDATA[<blockquote>
<p>当一个Activity执行了<code>onStop()</code>、Android 3.0之前执行<code>onPause()</code>方法时，将会被系统标记为<code>Killable</code>，在系统处于<code>extreme low memory</code> 的情况下，处于<code>Killable</code>状态的Activity将极有可能会被系统从内存释放（If an activity is paused or stopped,the system can drop the activity from memory by either asking it to finish, or simply killing its process） —— <a href="https://developer.android.google.cn/reference/android/app/Activity.html" target="_blank" rel="noopener">Activity API</a></p>
</blockquote>
<h2 id="默认情况下Fragment的restore过程"><a href="#默认情况下Fragment的restore过程" class="headerlink" title="默认情况下Fragment的restore过程"></a><strong>默认情况下Fragment的<code>restore</code>过程</strong></h2><p>➣当系统认为一个Activity处于Killable状态时会调用<code>Activity#onSaveInstanceState(Bundle outState)</code>方法进行数据的保存，Android3.0之前该方法的执行时机为：<code>onResume → onSaveInstanceState →onPause</code>，即调用onPause()之前；Android3.0之后：<code>onPause →onSaveInstanceState→ onStop</code>，即调用onStop()之前。<br>➣FragmentActivity的<code>onSaveInstanceState(Bundle outState)</code> 中会记录所有Fragment状态信息，源码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">    Parcelable p = mFragments.saveAllState();</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➣当用户重新回到被Killed的FragmentActivity时，Activity将会被重新创建，并进行之前<code>onSaveInstanceState(Bundle outState)</code>保存数据的<code>restore</code>过程，在<code>FragmentActivity#onCreate(Bundle savedInstanceState)</code>方法中会根据之前保存的Fragment状态信息进行Fragment的恢复（重新创建之前Activity中存在的所有Fragment），源码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line">         <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">              Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class="line">              mFragments.restoreAllState(p, nc != <span class="keyword">null</span> ? nc.fragments : <span class="keyword">null</span>);</span><br><span class="line">              ......</span><br><span class="line">          &#125;</span><br><span class="line">      mFragments.dispatchCreate();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>➣<code>restore</code>过程恢复的“旧”的Fragment将会随着Activity生命周期方法（<code>onStart</code>、<code>onResume</code>）的执行而执行相应的Fragment生命周期方法(<code>onCreateView</code>、<code>onActivityCreated</code>、<code>onResume</code>等)，从而完成Fragment的完整创建。如果我们在Activity中未做针对性处理，有时重新回到一个Activity的时候会出现<code>Fragment重叠</code>、自定义View功能失效甚至直接<code>Crash</code>等情况。</p>
<h2 id="如何简单有效的处理restore带来的问题"><a href="#如何简单有效的处理restore带来的问题" class="headerlink" title="如何简单有效的处理restore带来的问题"></a><strong>如何简单有效的处理<code>restore</code>带来的问题</strong></h2><p>&emsp;&emsp;正常情况下，restore过程带来的问题，根源是由于Activity在恢复之前“旧”的Fragment的同时，我们又重新创建新的Fragment导致的，也就是说此时Activity存在两份职责功能完全重复的Fragment，针对这个问题其实我们只需要注释掉Activity中保存Fragment状态的代码，让Activity在被Killed之前不去保存Fragment信息，那样在<code>FragmentActivity#onCreate(Bundle savedInstanceState)</code>方法中便无法进行相应的<code>restore</code>处理，也就是说“旧”的Fragment都将不复存在，界面只会显示我们新创建的Fragment，注释的具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//super.onSaveInstanceState(outState);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何复用restore产生的Fragment"><a href="#如何复用restore产生的Fragment" class="headerlink" title="如何复用restore产生的Fragment"></a><strong>如何复用<code>restore</code>产生的Fragment</strong></h2><p>&emsp;&emsp;注释掉代码的方式固然简单粗暴，但也牺牲了程序执行效率，以及可能带来较差的用户体验（用户可能看到短暂的黑屏现象）。Fragment的重新创建肯定没有复用来的高效，而且注释代码的方式也阻止了其它视图状态的保存。</p>
<h3 id="1-add-replace方式显示的Fragment"><a href="#1-add-replace方式显示的Fragment" class="headerlink" title="1. add/replace方式显示的Fragment"></a>1. add/replace方式显示的Fragment</h3><p><strong>&emsp;&emsp;对于普通的add/replace方式显示的Fragment，在Activity中可以在初始化之前根据<code>tag</code>使用<code>FragmentManager#findFragmentByTag</code>判断是否已经存在，代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Fragment中用Fragment#getChildFragmentManager()</span></span><br><span class="line">Fragment aFragment = getSupportFragmentManager().findFragmentByTag(<span class="string">"标识Fragment的Tag"</span>);</span><br><span class="line"><span class="keyword">if</span> (aFragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">    aFragment=<span class="keyword">new</span> FragmentA();</span><br><span class="line">    Bundle args = <span class="keyword">new</span> Bundle();</span><br><span class="line">    args.putString(<span class="string">"参数名"</span>, <span class="string">"参数值"</span>);</span><br><span class="line">    <span class="comment">//setArguments方法只能在attach到Activity之前调用</span></span><br><span class="line">    aFragment.setArguments(args);</span><br><span class="line">    <span class="comment">//同一个Fragment实例只能被add一次</span></span><br><span class="line">    getSupportFragmentManager().beginTransaction().</span><br><span class="line">                    add(R.id.container, aFragment,<span class="string">"标识Fragment的Tag"</span>).</span><br><span class="line">                    commitAllowingStateLoss();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-ViewPager-FragmentPagerAdapter"><a href="#2-ViewPager-FragmentPagerAdapter" class="headerlink" title="2. ViewPager+FragmentPagerAdapter"></a>2. ViewPager+FragmentPagerAdapter</h3><p><strong>&emsp;&emsp;在使用ViewPager嵌套Fragment的情况下，情况会和普通add/replace方式添加的Fragment有所不同，如果我们使用的是<code>FragmentPagerAdapter</code>，其在<code>instantiateItem</code>方法中会先通过tag查找Fragment,如果Fragment不存在，在add时会自动添加tag，源码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">       ......</span><br><span class="line">       <span class="comment">// Do we already have this fragment?</span></span><br><span class="line">       String name = makeFragmentName(container.getId(), itemId);</span><br><span class="line">       <span class="comment">//1、在instantiateItem中，因为是根据findFragmentByTag来确定fragment是否已经存在，所以在Activity的restore过程中虽然我们重新初始化了FragmentPagerAdapter中引用的Fragment[]，但是实际上ViewPager中最先用到的还是被Kill之前的FragmentManager中已有的Fragment（见下面注释2），如果FragmentManager中不存在，才会通过getItem(position)去获取Fragment[]中的Fragment</span></span><br><span class="line">       <span class="comment">//2、ViewPager#onSaveInstanceState()中会保存当前ViewPager选中的位置，在onRestoreInstanceState()中如果mAdapter不为null将会定位到保存的位置</span></span><br><span class="line">       Fragment fragment = mFragmentManager.findFragmentByTag(name);</span><br><span class="line">       <span class="keyword">if</span> (fragment != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mCurTransaction.attach(fragment);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           fragment = getItem(position);</span><br><span class="line">           <span class="comment">//add的Fragment的tag名称格式为："android:switcher:" + container.getId() + ":" + getItemId(position);如：android:switcher:2131758535:0</span></span><br><span class="line"></span><br><span class="line">           mCurTransaction.add(container.getId(), fragment,</span><br><span class="line">                   makeFragmentName(container.getId(), itemId));</span><br><span class="line">       &#125;</span><br><span class="line">       ......</span><br><span class="line">       <span class="keyword">return</span> fragment;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>&emsp;这种情况下，我们需要如何复用呢？分如下两种情况：</strong></p>
<h4 id="➣Activity与Fragment不需要进行交互"><a href="#➣Activity与Fragment不需要进行交互" class="headerlink" title="➣Activity与Fragment不需要进行交互"></a><strong>➣Activity与Fragment不需要进行交互</strong></h4><p>&emsp;&emsp;在Activity与Fragment不需要进行交互的情况下，我们不需要保持ViewPager中所显示Fragment的引用，只需要在<code>Adapter#getItem(int position)</code> 根据<code>position</code>直接返回创建的Fragment实例即可，具体原因在上述<code>FragmentPagerAdapter#instantiateItem()</code>方法中可以很清楚看到：restore过程中产生的fragment，ViewPager会直接利用，只有在当前初始化位置的<code>Fragment==null</code>时才会通过<code>getItem(position)</code>获取，因此可以在Adapter中使用如下方法初始化Fragment（<a href="https://developer.android.google.cn/reference/android/support/v4/app/FragmentPagerAdapter.html" target="_blank" rel="noopener">FragmentPagerAdapter</a>的example中使用的是类似的方式）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPageAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (position) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> Fragment0.newInstance(args);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> Fragment1.newInstance(args);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> Fragment2.newInstance(args);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> Fragment0.newInstance(args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="➣Activity与Fragment需要进行交互"><a href="#➣Activity与Fragment需要进行交互" class="headerlink" title="➣Activity与Fragment需要进行交互"></a><strong>➣Activity与Fragment需要进行交互</strong></h4><p>&emsp;&emsp; 如果我们在Activity中<strong>必须</strong>保持对ViewPager中显示的Fragment的直接引用，如TitleBar中有个刷新按钮（<em>仅从开发实际情况中选取示例，其实同样可以从FragmentManager中获取到，原则上是能不保持引用最好不保持</em>），我们需要实现点击按钮来刷新ViewPager当前的界面，就可以全局声明一个Fragment数组，来保持对ViewPager中用到的每个Fragment的引用，以便控制刷新。这种情况下在Activity中，我们需要对restore产生的Fragment进行查找和引用，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">final</span> String KEY_TAGS = <span class="string">"viewpager_fragment_tags"</span>;</span><br><span class="line">	    <span class="keyword">private</span> MyPageAdapter mPageAdapter;</span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_COUNT = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//当Activity需要与具体的Fragment交互时（如TitleBar中有个刷新按钮）可能需要保持对ViewPager中Fragments的引用</span></span><br><span class="line">	    <span class="keyword">private</span> Fragment[] fragments = <span class="keyword">new</span> Fragment[PAGE_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ViewPager viewPager = (ViewPager) findViewById(R.id.view_pager);</span><br><span class="line">        <span class="keyword">if</span> (savedInstanceState == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//第一次初始化的情况下直接创建</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PAGE_COUNT; i++) &#123;</span><br><span class="line">                fragments[i] = getFragment(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//根据保存的tag信息，复用restore产生的Fragment</span></span><br><span class="line">            String[] tags = savedInstanceState.getStringArray(KEY_TAGS);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PAGE_COUNT; i++) &#123;</span><br><span class="line">                fragments[i] = getFragmentWithTags(i, tags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mPageAdapter = <span class="keyword">new</span> MyPageAdapter(getSupportFragmentManager(), fragments);</span><br><span class="line">        viewPager.setAdapter(mPageAdapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据保存的tag信息，复用restore过程中产生的Fragment，Fragment不存在时直接创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> position 要初始化Fragment的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tags     &#123;<span class="doctag">@link</span> #onSaveInstanceState&#125;中保存的ViewPager中Fragment的Tag信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> FragmentManager中已有的Fragment或new出来的Fragment实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Fragment <span class="title">getFragmentWithTags</span><span class="params">(<span class="keyword">int</span> position, String[] tags)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tags == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getFragment(position);</span><br><span class="line">        &#125;</span><br><span class="line">        FragmentManager fragmentManager = getSupportFragmentManager();</span><br><span class="line">        <span class="keyword">if</span> (tags[position] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Fragment targetFragment = fragmentManager.findFragmentByTag(tags[position]);</span><br><span class="line">            <span class="keyword">return</span> targetFragment == <span class="keyword">null</span> ? getFragment(position) : targetFragment;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getFragment(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Fragment <span class="title">getFragment</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (position) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Fragment0();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Fragment1();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Fragment2();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Fragment0();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">        outState.putStringArray(KEY_TAGS, mPageAdapter.getInstantiateTags());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPageAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String[] mFragmentTags;</span><br><span class="line">        <span class="keyword">private</span> Fragment[] mFragments = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyPageAdapter</span><span class="params">(FragmentManager mFragmentManager, @NonNull Fragment[] fragments)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(mFragmentManager);</span><br><span class="line">            <span class="keyword">this</span>.mFragments = fragments;</span><br><span class="line">            mFragmentTags = <span class="keyword">new</span> String[mFragments.length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mFragments.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mFragments[position];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            Fragment fragment = (Fragment) <span class="keyword">super</span>.instantiateItem(container, position);</span><br><span class="line">            <span class="comment">//因为父类（FragmentPagerAdapter）是在本方法中为Fragment设置tag，所以我们在此方法中进行tag保存</span></span><br><span class="line">            mFragmentTags[position] = fragment.getTag();</span><br><span class="line">            <span class="keyword">return</span> fragment;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取实例化的ItemFragment设置的tag</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 与 &#123;<span class="doctag">@link</span> #PAGE_COUNT&#125;对应长度的tag数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> String[] getInstantiateTags() &#123;</span><br><span class="line">            <span class="keyword">return</span> mFragmentTags;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-ViewPager-FragmentStatePagerAdapter"><a href="#3-ViewPager-FragmentStatePagerAdapter" class="headerlink" title="3. ViewPager+FragmentStatePagerAdapter"></a>3. ViewPager+FragmentStatePagerAdapter</h3><p><strong>&emsp;&emsp;如果使用的是<code>FragmentStatePagerAdapter</code>，其与<code>FragmentPagerAdapter</code>也不同，<code>FragmentStatePagerAdapter</code>本身进行了状态的保存（<code>#restoreState(Parcelable state, ClassLoader loader)</code>）和恢复（<code>#saveState()</code>）处理，如果我们不需要保持ViewPager中所显示Fragment的引用，只需像<code>FragmentPagerAdapter</code>一样在<code>getItem(int position)</code>中直接return相应的Fragment对象即可；若</strong>必须<strong>要保持所显示Fragment的引用，可以通过反射的方式在初始化时反射为<code>Fragment#mTag</code>赋值，在初始化前同样根据<code>findFragmentByTag</code>判断是否已经存在。当然，特殊必要的情况下，我们可以不使用底层原有的保存机制，在研究透彻的基础上，自己编码进行Fragment列表及相关数据的保存</strong></p>
<h3 id="4-addToBackStack"><a href="#4-addToBackStack" class="headerlink" title="4. addToBackStack"></a>4. addToBackStack</h3><p><strong>&emsp;&emsp;在使用<code>FragmentTransaction#addToBackStack(String name)</code>将Fragment加入回退栈的情况下，由于在<code>FragmentActivity#onSaveInstanceState(Bundle outState)</code>方法中为所有Fragment都保存了状态信息（Saves the state for all Fragments），正常restore过程中也会将之前的Fragment的Stack状态恢复，如果没有特殊需要，正常情况下系统会帮我们恢复到之前显示的状态，不需要做特殊处理。</strong>（<a href="https://github.com/mayongnan/RestoreFragment.git" target="_blank" rel="noopener">Demo源码</a>）</p>
<p>需要注意的是，此篇文章主要探讨的是在FragmentActivity被系统强制销毁的情况下Fragment的恢复和复用问题，如果是一个复杂Activity被销毁，我们想回到销毁之前一模一样的状态，还需要处理Activity中View的内容、位置、状态等一些复杂信息的保存和恢复。</p>
]]></content>
      
        <categories>
            
            <category> 开发随记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Activity回收 </tag>
            
            <tag> Fragment复用 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Hexo搭建Github博客]]></title>
      <url>http://mayongnan.github.io/2016/05/05/hello_blog/</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>Hexo安装前提环境</strong></p>
<ul>
<li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li>
<li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a></li>
</ul>
</blockquote>
<p>　<strong>１．在Github上创建一个Respository</strong><br>　注意Respository name需为{your github name}.github.io的格式，此Respository用来存放Hexo生成的博客相关文件<br>　<strong>２．安装<a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a></strong><br>　安装了Git之后，就可以通过右击鼠标打开GitBash控制台，通过输入<code>$ npm install -g hexo-cli</code>命令进行Hexo的安装，安装完成后将可以在C:\Users{username}\AppData\Roaming\npm目录中看到hexo相关文件及node_modules相关文件夹，hexo-cli就在node_modules文件夹中<br>　<strong>３．初始化Hexo目录</strong><br> 安装完成后需要执行下面的命令，Hexo 将会在指定文件夹中新建所需要的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p>
<p>　初始化成功后可以在指定的文件夹中看到如下目录<br>　<br>　<img src="https://mayongnan.github.io/blogfiles/20160505_hello_hexo.jpg" alt="hexo-init-dir"></p>
<blockquote>
<p><em>_config.yml</em>：网站的配置信息，可以在此配置大部分的参数。 </p>
</blockquote>
<blockquote>
<p><em>package.json</em>：应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，可以自由移除。 　</p>
</blockquote>
<blockquote>
<p><em>scaffolds</em>：模版 文件夹。当新建文章时，Hexo会根据scaffold 来建立文件</p>
</blockquote>
<blockquote>
<p><em>source</em>：资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public文件夹，而其他文件会被拷贝过去。</p>
</blockquote>
<blockquote>
<p><em>themes</em>：主题文件夹。Hexo 会根据主题来生成静态页面</p>
</blockquote>
<p>　<strong>４．生成静态文件</strong><br> 　通过命令<code>$ hexo g</code>生成静态文件，生成了之后可以通过<code>$ hexo server</code>命令启动服务器，然后就可以通过访问网址为： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>  看到效果</p>
<p>　<strong>５．新建post</strong><br>　通过命令<code>$ hexo new [layout] &lt;title&gt;</code>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，使用引号括起来。<br>　<strong>６．部署到Github</strong><br>　首先要安装 hexo-deployer-git插件（之前的步骤中也可能需要进行相应插件的安装）。通过<code>$ npm install hexo-deployer-git --save</code>命令进行安装，安装成功后先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如部署到github(注意空格)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/&#123;username&#125;/&#123;username&#125;.github.io.git</span><br></pre></td></tr></table></figure></p>
<p>　最后只要通过命令 <code>$ hexo d</code>就可部署到github中，部署成功之后可以在Github相应Respository的Settings中看到Github Pages发布的地址，发布的地址格式一般为http://{username}.github.io<br> 　<strong>７．使用主题</strong><br> 　在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Themes</a>中挑选一个主题,查看具体使用方法并引用</p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github Blog </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
